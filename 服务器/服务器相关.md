# 服务器相关

## Linux

### 一. 常用命令

* 关机方面

  * ```bash
    sync # -- 同步数据到硬盘中
    shutdown # -- 关机(一般与sync一并使用)
    ```

* 目录结构

  * ```bash
    ls # -- 查看全部文件
    ```

  * 目录层级

    * ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/20210115214450337.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/20210115214450337.png)

  * 目录解释

    * /bin： bin是Binary的缩写, 这个目录存 放着最经常使用的命令。
    * /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。（不要动）
    * /dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。
    * ==/etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。==
    * ==/home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。==
    * /lib： 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。（不要动）
    * /lost+found： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（存放突然关机的一些文件）
    * /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。
    * /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。（我们后面会把一些本地文件挂载在这个目录下）
    * ==/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。==
    * /proc： 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。（不用管）
    * ==/root：该目录为系统管理员，也称作超级权限者的用户主目录。==
    * /sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。
    * /srv：该目录存放一些服务启动之后需要提取的数据。
    * /sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs 。
    * ==/tmp：这个目录是用来存放一些临时文件的。用完即丢的文件，可以放在这个目录下，安装包！==
    * ==/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。==
    * /usr/bin： 系统用户使用的应用程序。
    * /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序。Super
    * /usr/src： 内核源代码默认的放置目录。
    * /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。
    * /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。
    * /www：存放服务器网站相关的资源，环境，网站的项目

  * **绝对路径与相对路径**

    * **绝对路径：**路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。

    * **相对路径：**路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法啦！

  * > 处理目录常用命令

    - ls: 列出目录

      - ```bash
        [root@www ~]# ls [-aAdfFhilnrRSt] 目录名称
        ```

      - 参数

        - -a：全部文件 连同隐藏文件
        - -l：长数据串列出，包含文件的属性与权限等等数据；(常用)

      - ```bash
        [root@www ~]# ls -al ~  将目录下的所有文件列出来(含属性与隐藏档)
        ```

    - cd：切换目录

      - ``````
        cd [相对路径或绝对路径]
        ``````

      - ```bash
        # 切换到用户目录下
        [root@kuangshen /]# cd home  
        
        # 使用 mkdir 命令创建 kuangstudy 目录
        [root@kuangshen home]# mkdir kuangstudy
        
        # 进入 kuangstudy 目录
        [root@kuangshen home]# cd kuangstudy
        
        # 回到上一级
        [root@kuangshen kuangstudy]# cd ..
        
        # 回到根目录
        [root@kuangshen kuangstudy]# cd /
        
        # 表示回到自己的家目录，亦即是 /root 这个目录
        [root@kuangshen kuangstudy]# cd ~
        ```
    
    - pwd：显示目前的目录
    
      - ```bash
        [root@kuangshen kuangstudy]#pwd [-P]
        # 选项与参数：-P ：显示出确实的路径，而非使用连接(link) 路径。
        ```
    
      - ```bash
        # 单纯显示出目前的工作目录
        [root@kuangshen ~]# pwd
        /root
        
        # 如果是链接，要显示真实地址，可以使用 -P参数
        [root@kuangshen /]# cd bin
        [root@kuangshen bin]# pwd -P
        /usr/bin
        ```
    
    - mkdir：创建一个新的目录
    
      - ```bash
        mkdir [-mp] 目录名称
        # 选项与参数：
        
        -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～
        
        -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！
        ```
    
      - ```bash
        # 进入我们用户目录下
        [root@kuangshen /]# cd /home
        
        # 创建一个 test 文件夹
        [root@kuangshen home]# mkdir test
        
        # 创建多层级目录
        [root@kuangshen home]# mkdir test1/test2/test3/test4
        mkdir: cannot create directory ‘test1/test2/test3/test4’:
        No such file or directory  # <== 没办法直接创建此目录啊！
        
        # 加了这个 -p 的选项，可以自行帮你创建多层目录！
        [root@kuangshen home]# mkdir -p test1/test2/test3/test4
        
        # 创建权限为 rwx--x--x 的目录。
        [root@kuangshen home]# mkdir -m 711 test2
        [root@kuangshen home]# ls -l
        drwxr-xr-x 2 root root  4096 Mar 12 21:55 test
        drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1
        drwx--x--x 2 root root  4096 Mar 12 21:58 test2
        ```
    
    - rmdir：删除一个**空的目录**
    
      - ```bash
        rmdir [-p] 目录名称
        # 选项与参数：-p ：连同上一级『空的』目录也一起删除
        # rmdir只能删除【空目录】
        ```
    
      - ```bash
        # 看看有多少目录存在？
        [root@kuangshen home]# ls -l
        drwxr-xr-x 2 root root  4096 Mar 12 21:55 test
        drwxr-xr-x 3 root root  4096 Mar 12 21:56 test1
        drwx--x--x 2 root root  4096 Mar 12 21:58 test2
        
        # 可直接删除掉，没问题
        [root@kuangshen home]# rmdir test
        
        # 因为尚有内容，所以无法删除！
        [root@kuangshen home]# rmdir test1
        rmdir: failed to remove ‘test1’: Directory not empty
        
        # 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。
        [root@kuangshen home]# rmdir -p test1/test2/test3/test4
        ```
    
    - cp: 复制文件或目录
    
      - ```bash
        [root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)
        [root@www ~]# cp [options] source1 source2 source3 .... directory
        
        #选项与参数：
        
        -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)
        
        -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；
        
        -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；
        
        -r：递归持续复制，用於目录的复制行为；(常用)
        
        -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；
        
        -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)
        
        -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身。
        
        -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；
        
        -u：若 destination 比 source 旧才升级 destination ！
        ```
    
      - ```bash
        # 找一个有文件的目录，我这里找到 root目录
        [root@kuangshen home]# cd /root
        [root@kuangshen ~]# ls
        install.sh
        [root@kuangshen ~]# cd /home
        
        # 复制 root目录下的install.sh 到 home目录下
        [root@kuangshen home]# cp /root/install.sh /home
        [root@kuangshen home]# ls
        install.sh
        
        # 再次复制，加上-i参数，增加覆盖询问？
        [root@kuangshen home]# cp -i /root/install.sh /home
        cp: overwrite ‘/home/install.sh’? y # n不覆盖，y为覆盖
        ```
    
    - rm: 移除文件或目录
    
      - ```bash
        rm [-fir] 文件或目录
        #选项与参数：
        
        -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；
        
        -i ：互动模式，在删除前会询问使用者是否动作
        
        -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！
        ```
    
      - ```bash
        # 将刚刚在 cp 的实例中创建的 install.sh删除掉！
        [root@kuangshen home]# rm -i install.sh
        rm: remove regular file ‘install.sh’? y
        # 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！
        
        # 尽量不要在服务器上使用 rm -rf /
        ```
    
    - mv: 移动文件与目录，或修改文件与目录的名称
    
      - ```bash
        [root@www ~]# mv [-fiu] source destination
        [root@www ~]# mv [options] source1 source2 source3 .... directory
        #选项与参数：
        
        -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；
        
        -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！
        
        -u ：若目标文件已经存在，且 source 比较新，才会升级 (update)
        ```
    
      - ```bash
        # 复制一个文件到当前目录
        [root@kuangshen home]# cp /root/install.sh /home
        
        # 创建一个文件夹 test
        [root@kuangshen home]# mkdir test
        
        # 将复制过来的文件移动到我们创建的目录，并查看
        [root@kuangshen home]# mv install.sh test
        [root@kuangshen home]# ls
        test
        [root@kuangshen home]# cd test
        [root@kuangshen test]# ls
        install.sh
        
        # 将文件夹重命名，然后再次查看！
        [root@kuangshen test]# cd ..
        [root@kuangshen home]# mv test mvtest
        [root@kuangshen home]# ls
        mvtest
        ```
    
  * **文件属性**
  
    * 实例中，boot文件的第一个属性用"d"表示。"d"在Linux中代表该文件是一个目录文件。
  
      在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：
  
      - 当为[ **d** ]则是目录
      - 当为[ **-** ]则是文件；
      - 若是[ **l** ]则表示为链接文档 ( link file )；
      - 若是[ **b** ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；
      - 若是[ **c** ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。
  
      接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。
  
      其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。
  
      要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。
  
      每个文件的属性由左边第一部分的10个字符来确定（如下图）
  
      * ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211026182807.jpg](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211026182807.jpg)
  
      * 从左至右用0-9这些数字来表示。
  
        第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。
  
        其中：
  
        第1、4、7位表示读权限，如果用"r"字符表示，则有读权限，如果用"-"字符表示，则没有读权限；
  
        第2、5、8位表示写权限，如果用"w"字符表示，则有写权限，如果用"-"字符表示没有写权限；
  
        第3、6、9位表示可执行权限，如果用"x"字符表示，则有执行权限，如果用"-"字符表示，则没有执行权限。
  
    * > 在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。
      >
      > 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。
  
  * **修改文件属性**
  
    * **chmod：更改文件9个属性**
  
      * ```bash
        chmod [-R] xyz 文件或目录
        # r:4     w:2         x:1
        ```
  
      * 
  
        ```bash
        chmod 770 filename
        ```
  
  * **查看文件内容**
  
    * cat：由第一行开始显示文件内容
  
      * ```bash
        cat [-AbEnTv]
        # 选项与参数：
        -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；
        -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！
        -E ：将结尾的断行字节 $ 显示出来；
        -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；
        -T ：将 [tab] 按键以 ^I 显示出来；
        -v ：列出一些看不出来的特殊字符
        ```
  
    * tac：由最后一行开始显示文件内容
  
    * nl：显示行号
  
      * ```bash
        nl [-bnw] 文件
        # 选项与参数：
        -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；
        -n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；
        -w ：行号栏位的占用的位数。
        ```
  
      * ```bash
        [root@kuangshen ~]# nl /etc/sysconfig/network-scripts/ifcfg-eth0
        1DEVICE=eth0
        2BOOTPROTO=dhcp
        3ONBOOT=yes
        ```
  
    * more：一页页翻动
  
      * ```bash
        # 在 more 这个程序的运行过程中，你有几个按键可以按的：
        	空白键 (space)：代表向下翻一页；
        	Enter     ：代表向下翻『一行』；
        	/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；
        	:f      ：立刻显示出档名以及目前显示的行数；
        	q       ：代表立刻离开 more ，不再显示该文件内容。
        	b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。
        ```
  
      * ```bash
        [root@kuangshen etc]# more /etc/csh.login
        ....(中间省略)....
        --More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令
        ```
  
    * less：一页页翻动
  
      * ```bash
        # less运行时可以输入的命令有：
            空白键  ：向下翻动一页；
            [pagedown]：向下翻动一页；
            [pageup] ：向上翻动一页；
            /字串   ：向下搜寻『字串』的功能；
            ?字串   ：向上搜寻『字串』的功能；
            n     ：重复前一个搜寻 (与 / 或 ? 有关！)
            N     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)
            q     ：离开 less 这个程序；
        ```
  
    * head：取出文件前几行
  
      * ```bash
        head [-n number] 文件
        # 选项与参数：-n 后面接数字，代表显示几行的意思！
        ```
  
    * tail：取出文件后几行
  
      * ```bash
        tail [-n number] 文件
        # 选项与参数：-n ：后面接数字，代表显示几行的意思
        ```

### 二. 账号管理

* 内容：

  * 用户账户添加 删除 修改
  * 用户口令管理
  * 用户组管理

* **用户账号管理**

  * 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。

  * 添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。

  * **添加账号 useradd**

    * ```bash
      useradd 选项 用户名
      #参数说明：
      选项 :
      -c comment 指定一段注释性描述。
      -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
      -g 用户组 指定用户所属的用户组。
      -G 用户组，用户组 指定用户所属的附加组。
      -m　使用者目录如不存在则自动建立。
      -s Shell文件 指定用户的登录Shell。
      -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。
      ```

    * ```bash
      # 此命令创建了一个用户kuangshen，其中-m选项用来为登录名kuangshen产生一个主目录 /home/kuangshen
      [root@kuangshen home]# useradd -m kuangshen
      ```

    * 增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等

  * **删除用户**

    * ```bash
      userdel 选项 用户名
      # 常用的选项是 -r，它的作用是把用户的主目录一起删除。
      ```

    * ```bash
      [root@kuangshen home]# userdel -r kuangshen
      ```

  * **修改账号**

    * ```bash
      usermod 选项 用户名
      ```

  * **切换账号**

    * ```bash
      #1.切换用户的命令为：su username 【username是你的用户名哦】
      #2.从普通用户切换到root用户，还可以使用命令：sudo su
      #3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令
      #4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】
      
      '$' 表示普通用户
      '#' 表示超级用户，也就是root用户
      ```

* **用户口令管理**

  * 超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。

  * 用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。

  * ```bash
    passwd 选项 用户名
    #可使用的选项：
    -l 锁定口令，即禁用账号。
    -u 口令解锁。
    -d 使账号无口令。
    -f 强迫用户下次登录时修改口令。
    ```

  * 普通用户：例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令：

    * ```bash
      $ passwd
      Old password:******
      New password:*******
      Re-enter new password:*******
      ```

  * root用户：

    * ```bash
      # passwd kuangshen
      New password:*******
      Re-enter new password:*******
      ```

  * 为用户指定空口令时，令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。

* **用户组管理**

  * 每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。

  * 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。

  * ```bash
    groupadd 选项 用户组
    #可以使用的选项有：
    -g GID 指定新用户组的组标识号（GID）。
    -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。
    ```

  * ```bash
    # groupadd group1
    # 此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。
    
    # groupadd -g 101 group2
    # 此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。
    ```

  * ```bash
    groupdel 用户组
    # 如果要删除一个已有的用户组，使用groupdel命令
    ```

  * ```bash
    groupmod 选项 用户组
    # 修改用户组的属性使用groupmod命令
    #常用的选项有：
    -g GID 为用户组指定新的组标识号。
    -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
    -n新用户组 将用户组的名字改为新名字
    ```

  * ```bash
    # 此命令将组group2的组标识号修改为102。
    groupmod -g 102 group2
    
    # 将组group2的标识号改为10000，组名修改为group3。
    groupmod –g 10000 -n group3 group2
    ```

* **/etc/passwd文件是用户管理工作涉及的最重要的一个文件。**

  * Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。

### 三. 磁盘管理

* Linux磁盘管理常用命令为 df、du。

  * df ：列出文件系统的整体磁盘使用量
  * du：检查磁盘空间使用量

* **df**：

  * ```bash
    df [-ahikHTm] [目录或文件名]
    #选项与参数：
    -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；
    -k ：以 KBytes 的容量显示各文件系统；
    -m ：以 MBytes 的容量显示各文件系统；
    -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；
    -H ：以 M=1000K 取代 M=1024K 的进位方式；
    -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；
    -i ：不用硬盘容量，而以 inode 的数量来显示
    ```

* **du**：

  * ```bash
    du [-ahskm] 文件或目录名称
    #选项与参数：
    -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。
    -h ：以人们较易读的容量格式 (G/M) 显示；
    -s ：列出总量而已，而不列出每个各别的目录占用容量；
    -S ：不包括子目录下的总计，与 -s 有点差别。
    -k ：以 KBytes 列出容量显示；
    -m ：以 MBytes 列出容量显示；
    ```

### 四.环境配置

* 

## Nginx

### 一. 概念作用

#### 1. 作用

* **反向代理**
  * **反向代理（Reverse Proxy）方式**是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。
  * **正向代理**，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。
  * 两者的区别：
    * **正向代理**即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.
    * **反向代理**即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端
    * ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/1350514-20190313105354768-2077480083.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/1350514-20190313105354768-2077480083.png)
* **负载均衡**
* **动静分离**
  * Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现
  * 一般来说，都需要将动态资源和静态资源分开，将静态资源部署在Nginx上，当一个请求来的时候，如果是静态资源的请求，就直接到nginx配置的静态资源目录下面获取资源，如果是动态资源的请求，nginx利用反向代理的原理，把请求转发给后台应用去处理，从而实现动静分离。
    * 在使用前后端分离之后，可以很大程度的提升静态资源的访问速度，同时在开过程中也可以让前后端开发并行可以有效的提高开发时间，也可以有些的减少联调时间 。

### 二. 使用

#### 1. 常用命令：

* **查看版本**   **./nginx -v**
* **启动Nginx**   **./nginx**
* **停止Nginx**   **./nginx -s stop**
* **重新加载Nginx**   **./nginx -s reload**
  * **所有的命令操作 都需要进入nginx目录 /usr/local/nginx/sbin**

#### 2. 配置

* **位置   /usr/local/nginx/conf/nginx.conf**

* **组成**

  * **全局块**：主要设置**影响Nginx服务器整体运行**的配置
    * e.g. ```worker_processes   1;``` 表示服务器并发处理服务的配置
  * **events块**：主要设置**影响Nginx服务器与用户网络连接**的部分 **重要**
    * e.g. ```worker connections  1024;``` 表示服务器支持最大连接数的配置
  * **http块**：主要设置 **文件引入  日志自定义 连接超时时间 单连接请求数上限...**  等信息
    * **server**：

* **反向代理**

  * 步骤：

    * Linux中安装Tomcat 并 启动

    * 对外开放访问端口

      * ```firewall-cmd-add-port=80/tcp --permanent```
      * ```firewall-cmd --list-all```查看开放的端口号

    * 【可选】修改windows的host文件配置域名映射

    * ```nginx.conf```中在**server块**中的```server_name```为映射的**ip**

    * ```nginx.conf```中在**server块**中的**location块**中增加```proxy_pass``` 值为tomcat的路径(e.g. ```127.0.0.1:8080```)

      * ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211021191718.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211021191718.png)

    * 如果想对location转发有多个路径

    * ```nginx
      server{
          listen 9001;
          server_name localhost;
          location ~ /edu/ {
              proxy_pass http://127.0.0.1:8080;
          }
          location ~ /vod/ {
              proxy_pass http://127.0.0.1:8080;
          }
      }
      ```

* **负载均衡**

  * 步骤

    * 在**http块**中添加如下配置

    * ```nginx
      upstream myserver{
          #ip_hash;//策略名称
          server 115.28.52.63:8080 weight=1;
          server 115.28.52.63:8081 weight=1;
      }
      ```

    * 在**http块**中的**location块**中添加转发规则 同反向代理 这里省略

  * 策略

    * **轮询**：按照**时间**顺序分配到不同的服务器 **默认**
    * **加权**：指定轮询几率 **weight与访问几率成正比** 可用于服务器性能不均的情形
    * **ip_hash**：每个请求按照访问ip的hash分配服务器 每一个访客都固定访问一个服务器 可解决session的问题
    * **fair**：根据服务器响应时间分配 谁响应快分配谁 
      * 使用此方式在```server 115.28.52.63:8081;```后添加```fair;```即可

* **动静分离**

  * Tips

    * 通过```location```指定不同后缀名实现不同请求转发
    * 可设置```expires```参数 设置浏览器缓存过期时间 减少与服务器间的请求与流量
      * **Expires**：给资源一个过期时间 无需去服务端验证 可通过浏览器自身确定是否过期 十分适合补偿变动的资源
        * e.g.```3d``` 表示三天之内发送请求如果该文件没有变化则不回去服务器抓取 

  * 步骤：

    * 配置文件中修改**server块**中的```server_name```

    * 修改**server块**中的**location块**

      * ```nginx
        location /www/ {
            #root表示静态资源路径 e.g. /data/www/a.html
            root /data/;
            index index.html index.htm;
            # 列出当前文件夹中的内容
            autoindex on;
            # 设置资源过期时间
            expires 3d;
        }
        
        
        #动态访问请求转给tomcat应用处理
        location ~ .(jsp|page|do)?$ {      #以这些文件结尾的
            proxy_set_header  Host $host;
            proxy_set_header  X-Real-IP  $remote_addr;
            proxy_pass http://tomcat地址;
        }
        
        #设定访问静态文件直接读取不经过tomcat
        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$  {     #以这些文件结尾的
            expires      30d;
            root /data/web/html ;
        }
        ```

* **高可用配置**

  * ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211021195508.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211021195508.png)

  * 几个概念：

    * 虚拟ip：Nginx负载均衡实现高可用 需要借助**keepalived**的**地址漂移功能** 该功能需要一个虚拟ip
    * ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/16973075-b29105b83d74503a.webp](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/16973075-b29105b83d74503a.webp)
    * **keepalived**：
      * 简单讲 基本是个路由 **负责监测Nginx是否宕机** 如果宕机 则将**虚拟ip由Nginx主节点绑定到从节点**

  * 步骤（两台服务器为例）

    * 两台服务器中安装**keepalived**

      * ```yum install keepalived -y```
      * ```rpm -q -a keepalived```

    * 修改```/etc/keepalived/keepalived.conf``` 

      * ```nginx
        vrrp_script chk_http_port{
            #脚本中的条件成立 则按照规则执行
            script "/usr/local/src/nginx_check.sh" 
                interval 2 #检测脚本执行的间隔
                weight 2
        }
        ```

      * ```nginx
        vrrp_instance VI_1{
            state MASTER #这里如果是主Nginx 为MASTER； 如果是从Nginx 为BACKUP
                interface ens33 #指定绑定网卡信息
                virtual_router_id 51 #主节点 从节点 id必须相同
                priority 100 # 主 从 节点取不同优先级 主节点大 从节点小 一般主节点100
                virtual_iddress{
                ...#设置虚拟ip地址
                    #此处不唯一 可绑定多个虚拟ip
            }
        }
        ```

      * 将写好的**检测脚本**放到检测路径中(e.g. ```"/usr/local/src/nginx_check.sh"```)

      * 启动两台服务器上的Nginx与keepalived即可

        * ```systemctl start keepalived.service ed```

      * 测试访问**虚拟ip**即可

## Docker

### 一. 概念

* **Docker能干嘛？**

  * 比较Docker和虚拟机技术的不同：
    - 传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件
    - 容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以
      就轻便了
    - 每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响

* **优势**

  * 应用更快速的交付和部署
    * 传统：一对帮助文档，安装程序。
    * Docker：打包镜像发布测试一键运行。
  * 更便捷的升级和扩缩容
    * 使用了 Docker之后，我们部署应用就和搭积木一样
    * 项目打包为一个镜像，扩展服务器A！服务器B

  - 更简单的系统运维
    - 在容器化之后，我们的开发，测试环境都是高度一致的

  - 更高效的计算资源利用
    - Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨
      到极致。

### 二. 基本组成

* ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/6e11bdf05f61489d951e63c735ab3d80.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/6e11bdf05f61489d951e63c735ab3d80.png)

* **镜像image**：模板，可通过镜像创建容器

  * ```bash
    # tomcat镜像 --> run --> tomcat1容器（提供服务）
    # 一个镜像可以启动多个容器
    ```

* **容器container**：是通过镜像来创建的，可独立运行一个或一组应用

  * 简单可理解为一个Linux系统

* **仓库repository**：存放镜像的地方

  * 分为公有仓库与私有仓库

### 三. 安装

> 环境准备

* ```bash
  # 卸载老版本docker
  yum remove docker \
  docker-client \
  docker-client-latest \
  docker-common \
  docker-latest \
  docker-latest-logrotate \
  docker-logrotate \
  docker-engine
  ```

* ```bash
  # 安装安装包
  yum install -y yum-utils
  ```

* ```bash
  # 设置镜像仓库
  yum-config-manager \ --add-repo \ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
  ```

* ```bash
  # 更新yum软件包索引
  yum makecache fast
  ```

* ```bash
  # 安装docker相关
  yum install docker-ce docker-ce-cli containerd.io
  ```

* ```bash
  # 启动docker
  systemctl start docker
  ```

* ```bash
  # 确认安装成功
  docker version
  ```

* ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211026194125.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211026194125.png)

* ```bash
  # 运行Hello World
  docker run hello-world
  ```

* ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211026194501.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211026194501.png)

* ```bash
  # 查看镜像列表
  docker images
  ```

* ```bash
  # 卸载docker
  yum remove docker ce docker ce cli containerd.io
  # 删除资源
  rm -rf /var/lib/docker

* **aliyun镜像加速**

  * 登录阿里云 找到**容器镜像服务**

  * 修改daemon配置文件```/etc/docker/daemon.json```

    * ```bash
      sudo mkdir -p /etc/docker
      sudo tee /etc/docker/daemon.json <<-'EOF'
      {
        "registry-mirrors": ["https://x6szbbsh.mirror.aliyuncs.com"]
      }
      EOF
      sudo systemctl daemon-reload
      sudo systemctl restart docker
      ```


### 四.Docker原理

* **Docker执行Run后的流程**
  * ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/Docker%E6%89%A7%E8%A1%8CRun%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/Docker%E6%89%A7%E8%A1%8CRun%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B.png)

* **Docker如何工作**
* **Docker为什么比VM块**
  * **Docker比VM有着更少的抽象层**
    * Docker不需要Hypervisor实现**硬件资源虚拟化**，使用的是物理机硬件资源，所以在**CPU及内存的利用率**上有明显优势
  * **Docker利用宿主机的内核，而不需要GuestOS**
    * Docker新建容器时，无需像VM一样加载**操作系统内核**，加载操作系统内核是比较费时费资源的过程，Docker**直接利用宿主机的操作系统**，使得分钟级的操作变成了秒级
  * ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/1188507-20201012225809671-16907909.jpg](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/1188507-20201012225809671-16907909.jpg)

### 五.Docker常用命令

#### 5.1 帮助命令

~~~bash
docker version # docker基本信息
docker info # docker详细信息
docker 命令 --help # 命令的使用
~~~

#### 5.2 镜像命令

* **docker images**：查看本地主机的所有镜像

  * ~~~bash
    [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker images
    REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
    hello-world   latest    feb5d9fea6a5   5 weeks ago   13.3kB
    
    # Tips
    RESPOSITORY 镜像仓库源 TAG 镜像标签 IMAGE ID 镜像ID CREATED镜像创建时间 SIZE 镜像大小
    
    # 可选参数
    Options:
    -a, --all # 列出所有镜像
    -q, --quiet # 只显示镜像id
    ~~~

* **docker search**：搜索镜像

  * ~~~bash
    [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker search mysql
    NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
    mysql                             MySQL is a widely used, open-source relation…   11603     [OK]       
    mariadb                           MariaDB Server is a high performing open sou…   4414      [OK]       
    mysql/mysql-server                Optimized MySQL Server Docker images. Create…   857                  [OK]
    
    #可选参数
    --filter=STARS=3000 #只显示收藏数大于3000的镜像
    e.g.
        [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker search mysql --filter=STARS=5000
        NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
        mysql     MySQL is a widely used, open-source relation…   11603     [OK]   
    ~~~

* **docker pull**：下载镜像

  * ~~~bash
    # docker pull 镜像名[:tag] 
    [root@iZ8vbgc3u6dvwrjyp45lyrZ /]# docker pull mysql
    Using default tag: latest # 不写tag默认下载最新的latest
    latest: Pulling from library/mysql
    b4d181a07f80: Pull complete # 分层下载 docker image 的核心 联合文件系统
    a462b60610f5: Pull complete 
    578fafb77ab8: Pull complete 
    524046006037: Pull complete 
    d0cbe54c8855: Pull complete 
    aa18e05cc46d: Pull complete 
    32ca814c833f: Pull complete 
    9ecc8abdb7f5: Pull complete 
    ad042b682e0f: Pull complete 
    71d327c6bb78: Pull complete 
    165d1d10a3fa: Pull complete 
    2f40c47d0626: Pull complete 
    Digest: sha256:52b8406e4c32b8cf0557f1b74517e14c5393aff5cf0384eff62d9e81f4985d4b # 签名
    Status: Downloaded newer image for mysql:latest
    docker.io/library/mysql:latest # 真实地址
    
    # docker pull mysql 等价于 docker pull .io/library/mysql:latest
    
    [root@iZ8vbgc3u6dvwrjyp45lyrZ /]# docker pull mysql:5.7
    5.7: Pulling from library/mysql
    b4d181a07f80: Already exists # 镜像共用 节省内存
    a462b60610f5: Already exists 
    578fafb77ab8: Already exists 
    524046006037: Already exists 
    d0cbe54c8855: Already exists 
    aa18e05cc46d: Already exists 
    32ca814c833f: Already exists 
    52645b4af634: Pull complete 
    bca6a5b14385: Pull complete 
    309f36297c75: Pull complete 
    7d75cacde0f8: Pull complete 
    Digest: sha256:1a2f9cd257e75cc80e9118b303d1648366bc2049101449bf2c8d82b022ea86b7
    Status: Downloaded newer image for mysql:5.7
    docker.io/library/mysql:5.7
    ~~~

* **docker rmi**：删除镜像(rmi = rm image )

  * ~~~bash
    [root@iZ8vbgc3u6dvwrjyp45lyrZ /]# docker rmi -f 镜像id         # 删除指定的镜像
    [root@iZ8vbgc3u6dvwrjyp45lyrZ /]# docker rmi -f 镜像id 镜像id 镜像id 镜像id   # 删除多个镜像
    [root@iZ8vbgc3u6dvwrjyp45lyrZ /]# docker rmi -f $(docker images -aq)     # 删除全部的镜像
    
    [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker rmi -f feb5d9fea6a5
    Untagged: hello-world:latest
    Untagged: hello-world@sha256:37a0b92b08d4919615c3ee023f7ddb068d12b8387475d64c622ac30f45c29c51
    Deleted: sha256:feb5d9fea6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412
    [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker images
    REPOSITORY   TAG       IMAGE ID   CREATED   SIZE
    ~~~

#### 5.3 容器命令

> 说明：有镜像才能创建容器，下载一个Centos测试

* **新建容器并启动**

  * ~~~bash
    # 下载Centos镜像
    
    [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker pull centos
    Using default tag: latest
    latest: Pulling from library/centos
    a1d0c7532777: Pull complete 
    Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177
    Status: Downloaded newer image for centos:latest
    docker.io/library/centos:latest
    
    # docker run [可选参数] image
    #参数说明
    # 参数说明
    --name="Name"     容器名字   tomcat01   tomcat02，  用来区分容器
    -d                后台方式运行
    -it               使用交互方式运行，进入容器查看内容
    -p                指定容器的端口 -p  8080:8080
        -p   ip:主机端口:容器端口
        -p   主机端口:容器端口（常用）
        -p   容器端口
        容器端口
    -p                随机指定端口
    
    # 测试 启动并进入容器
    [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker run -it centos /bin/bash
    # 主机名为镜像ID
    [root@168c31e65620 /]# ls
    bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var
    dev  home  lib64  media       opt  root  sbin  sys  usr
    
    # 从容器中退到主机【容器停止】
    [root@168c31e65620 /]# exit
    # 从容器中退到主机【容器不停止】 ctrl+P+Q
    
    # 查看当前运行的容器
    [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker ps
    CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES
    ccf8b426213d   centos    "/bin/bash"   2 minutes ago   Up 2 minutes             gracious_mirzakhani
    [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker ps -a(-a的意思：all) 查看曾经运行过的容器
    CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                          PORTS     NAMES
    168c31e65620   centos         "/bin/bash"   3 minutes ago   Exited (0) About a minute ago             mystifying_chandrasekhar
    55f7416ce8ef   feb5d9fea6a5   "/hello"      2 days ago      Exited (0) 2 days ago                     exciting_torvalds
    
    #docker ps命令 #列出当前正在运行的容器
        # 列出当前正在运行的容器
    -a  # 列出当前正在运行的容器+带出历史运行过的容器
    -n=? # 显示最近创建的容器
    -q  # 只显示容器的编号
    ~~~

* **删除容器**

  * ~~~bash
    docker rm 容器id     # 删除指定容器，不能删除正在运行的容器，如果要强制删除  
    rm -fdocker rm -f $(docker ps -aq)  # 删除所有的容器
    docker ps -a -q|xargs docker rm  # 删除所有的容器
    ~~~

* **启动与停止容器**

  * ~~~bash
    docker start 容器id     # 启动容器
    docker restart 容器id   # 重启容器
    docker stop 容器id      # 停止当前正在运行的容器 
    docker kill 容器id      # 强制停止当前容器
    ~~~

#### 5.4 常用其他命令

* 后台启动容器

  * ~~~bash
    # 命令 docker  run -d 镜像名！
    [root@iZ8vbgc3u6dvwrjyp45lyrZ ~]# docker run -d centos 
    # 问题docker  ps，发现centos停止了
    # 常见的坑，docker 容器使用后台运行，就必须要有一个前台进程， docker 发现没有应用，就会自动停止
    # nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了
    ~~~

* **查看日志**

  * ~~~bash
    # docker logs
    [root@iZ8vbgc3u6dvwrjyp45lyrZ ~]# docker logs --help
    Usage:  docker logs [OPTIONS] CONTAINER
    Fetch the logs of a container
    Options:      
        --details        Show extra details provided to logs  
        -f, --follow         Follow log output      
        --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)  
        -n, --tail string    Number of lines to show from the end of the logs (default "all")  
        -t, --timestamps     Show timestamps      
        --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)
    docker logs -f -t --tail  容器，没有日志
    # 自己编写一段shell脚本
    ➜ ~ docker run -d centos /bin/sh -c "while true;do echo 6666;sleep 1;done" #模拟日志
    [root@iZ8vbgc3u6dvwrjyp45lyrZ ~]# docker ps
    CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES596b80f933ac   centos    "/bin/sh -c 'while t…"   9 seconds ago   Up 8 seconds             priceless_meninsky
    # 显示日志
    -tf        #显示日志
    --tail=number     #要显示日志条数
    [root@iZ8vbgc3u6dvwrjyp45lyrZ ~]# docker logs -tf --tail 10 596b80f933ac
    [root@iZ8vbgc3u6dvwrjyp45lyrZ ~]# docker logs -tf --tail=10 596b80f933ac
    ~~~

* **查看容器中的进程信息**

  * ~~~bash
    [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker top 9b8d4a0c7748
    UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
    root                17761               17718               0                   12:54               pts/0               00:00:00            /bin/bash
    ~~~

* **查看容器中元数据**

  * ~~~bash
    [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker inspect 9b8d4a0c7748
    [
        {
            "Id": "9b8d4a0c7748034140dcd4d9c67fbe886787b1f16b4ce9c872621966caa173b4",
            "Created": "2021-10-29T04:54:28.839617847Z",
            "Path": "/bin/bash",
            "Args": [],
            "State": {
                "Status": "running",
                "Running": true,
                "Paused": false,
                "Restarting": false,
                "OOMKilled": false,
                "Dead": false,
                "Pid": 17761,
                "ExitCode": 0,
                "Error": "",
                "StartedAt": "2021-10-29T04:54:29.331011696Z",
                "FinishedAt": "0001-01-01T00:00:00Z"
            },
            "Image": "sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6",
            "ResolvConfPath": "/var/lib/docker/containers/9b8d4a0c7748034140dcd4d9c67fbe886787b1f16b4ce9c872621966caa173b4/resolv.conf",
            "HostnamePath": "/var/lib/docker/containers/9b8d4a0c7748034140dcd4d9c67fbe886787b1f16b4ce9c872621966caa173b4/hostname",
            "HostsPath": "/var/lib/docker/containers/9b8d4a0c7748034140dcd4d9c67fbe886787b1f16b4ce9c872621966caa173b4/hosts",
            "LogPath": "/var/lib/docker/containers/9b8d4a0c7748034140dcd4d9c67fbe886787b1f16b4ce9c872621966caa173b4/9b8d4a0c7748034140dcd4d9c67fbe886787b1f16b4ce9c872621966caa173b4-json.log",
            "Name": "/confident_cannon",
            "RestartCount": 0,
            "Driver": "overlay2",
            "Platform": "linux",
            "MountLabel": "",
            "ProcessLabel": "",
            "AppArmorProfile": "",
            "ExecIDs": null,
            "HostConfig": {
                "Binds": null,
                "ContainerIDFile": "",
                "LogConfig": {
                    "Type": "json-file",
                    "Config": {}
                },
                "NetworkMode": "default",
                "PortBindings": {},
                "RestartPolicy": {
                    "Name": "no",
                    "MaximumRetryCount": 0
                },
                "AutoRemove": false,
                "VolumeDriver": "",
                "VolumesFrom": null,
                "CapAdd": null,
                "CapDrop": null,
                "CgroupnsMode": "host",
                "Dns": [],
                "DnsOptions": [],
                "DnsSearch": [],
                "ExtraHosts": null,
                "GroupAdd": null,
                "IpcMode": "private",
                "Cgroup": "",
                "Links": null,
                "OomScoreAdj": 0,
                "PidMode": "",
                "Privileged": false,
                "PublishAllPorts": false,
                "ReadonlyRootfs": false,
                "SecurityOpt": null,
                "UTSMode": "",
                "UsernsMode": "",
                "ShmSize": 67108864,
                "Runtime": "runc",
                "ConsoleSize": [
                    0,
                    0
                ],
                "Isolation": "",
                "CpuShares": 0,
                "Memory": 0,
                "NanoCpus": 0,
                "CgroupParent": "",
                "BlkioWeight": 0,
                "BlkioWeightDevice": [],
                "BlkioDeviceReadBps": null,
                "BlkioDeviceWriteBps": null,
                "BlkioDeviceReadIOps": null,
                "BlkioDeviceWriteIOps": null,
                "CpuPeriod": 0,
                "CpuQuota": 0,
                "CpuRealtimePeriod": 0,
                "CpuRealtimeRuntime": 0,
                "CpusetCpus": "",
                "CpusetMems": "",
                "Devices": [],
                "DeviceCgroupRules": null,
                "DeviceRequests": null,
                "KernelMemory": 0,
                "KernelMemoryTCP": 0,
                "MemoryReservation": 0,
                "MemorySwap": 0,
                "MemorySwappiness": null,
                "OomKillDisable": false,
                "PidsLimit": null,
                "Ulimits": null,
                "CpuCount": 0,
                "CpuPercent": 0,
                "IOMaximumIOps": 0,
                "IOMaximumBandwidth": 0,
                "MaskedPaths": [
                    "/proc/asound",
                    "/proc/acpi",
                    "/proc/kcore",
                    "/proc/keys",
                    "/proc/latency_stats",
                    "/proc/timer_list",
                    "/proc/timer_stats",
                    "/proc/sched_debug",
                    "/proc/scsi",
                    "/sys/firmware"
                ],
                "ReadonlyPaths": [
                    "/proc/bus",
                    "/proc/fs",
                    "/proc/irq",
                    "/proc/sys",
                    "/proc/sysrq-trigger"
                ]
            },
            "GraphDriver": {
                "Data": {
                    "LowerDir": "/var/lib/docker/overlay2/624ab23413bfb4e8ba13b16cfa96f3e6df7b3f48b9f64b28303c9ff47f988093-init/diff:/var/lib/docker/overlay2/3aaa18e4313eacbd1dc0bc5a68fe305fbdab6d378f86b67b389ffd83f220d7ac/diff",
                    "MergedDir": "/var/lib/docker/overlay2/624ab23413bfb4e8ba13b16cfa96f3e6df7b3f48b9f64b28303c9ff47f988093/merged",
                    "UpperDir": "/var/lib/docker/overlay2/624ab23413bfb4e8ba13b16cfa96f3e6df7b3f48b9f64b28303c9ff47f988093/diff",
                    "WorkDir": "/var/lib/docker/overlay2/624ab23413bfb4e8ba13b16cfa96f3e6df7b3f48b9f64b28303c9ff47f988093/work"
                },
                "Name": "overlay2"
            },
            "Mounts": [],
            "Config": {
                "Hostname": "9b8d4a0c7748",
                "Domainname": "",
                "User": "",
                "AttachStdin": true,
                "AttachStdout": true,
                "AttachStderr": true,
                "Tty": true,
                "OpenStdin": true,
                "StdinOnce": true,
                "Env": [
                    "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
                ],
                "Cmd": [
                    "/bin/bash"
                ],
                "Image": "centos",
                "Volumes": null,
                "WorkingDir": "",
                "Entrypoint": null,
                "OnBuild": null,
                "Labels": {
                    "org.label-schema.build-date": "20210915",
                    "org.label-schema.license": "GPLv2",
                    "org.label-schema.name": "CentOS Base Image",
                    "org.label-schema.schema-version": "1.0",
                    "org.label-schema.vendor": "CentOS"
                }
            },
            "NetworkSettings": {
                "Bridge": "",
                "SandboxID": "9824b115f46074998658e6640d4f1756b5c2aa25e228b1b15de379e9a280d105",
                "HairpinMode": false,
                "LinkLocalIPv6Address": "",
                "LinkLocalIPv6PrefixLen": 0,
                "Ports": {},
                "SandboxKey": "/var/run/docker/netns/9824b115f460",
                "SecondaryIPAddresses": null,
                "SecondaryIPv6Addresses": null,
                "EndpointID": "14687ba67d9817cc06545ee395f8b509c189d9dcbf2557d0d872fe398516b79e",
                "Gateway": "172.17.0.1",
                "GlobalIPv6Address": "",
                "GlobalIPv6PrefixLen": 0,
                "IPAddress": "172.17.0.2",
                "IPPrefixLen": 16,
                "IPv6Gateway": "",
                "MacAddress": "02:42:ac:11:00:02",
                "Networks": {
                    "bridge": {
                        "IPAMConfig": null,
                        "Links": null,
                        "Aliases": null,
                        "NetworkID": "0e08e67efd47b3d73501110c9b54fbdabf8ef23dfa8ca60dcd355c5ffb996737",
                        "EndpointID": "14687ba67d9817cc06545ee395f8b509c189d9dcbf2557d0d872fe398516b79e",
                        "Gateway": "172.17.0.1",
                        "IPAddress": "172.17.0.2",
                        "IPPrefixLen": 16,
                        "IPv6Gateway": "",
                        "GlobalIPv6Address": "",
                        "GlobalIPv6PrefixLen": 0,
                        "MacAddress": "02:42:ac:11:00:02",
                        "DriverOpts": null
                    }
                }
            }
        }
    ]
    
    ~~~

* **进入当前正在运行的容器**

  * ~~~bash
    # 通常容器都是运行在后台方式的 需要进入容器 修改配置
    
    # 命令1
    docker exec -it 容器id bashShell
    
    # 测试1
    [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker exec -it 9b8d4a0c7748 /bin/bash
    [root@9b8d4a0c7748 /]# ls
    bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var
    dev  home  lib64  media       opt  root  sbin  sys  usr
    [root@9b8d4a0c7748 /]# ps -ef
    UID        PID  PPID  C STIME TTY          TIME CMD
    root         1     0  0 04:54 pts/0    00:00:00 /bin/bash
    root        15     0  0 05:05 pts/1    00:00:00 /bin/bash
    root        30    15  0 05:06 pts/1    00:00:00 ps -ef
    
    # 命令2
    docker attach 容器id
    
    # 测试2
    [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker attach 9b8d4a0c7748 
    ==> 正在执行的代码....
    
    # 两者区别
    	# docker exec 进入容器后开启一个新的终端 可以在里面操作（常用）
    	# docker attach 进入容器正在执行的终端
    ~~~

* **从容器中拷贝文件到主机上**

  * ~~~bash
    docker cp 容器id：容器内路径 目的主机路径
    
    # 测试
    
    # 首先在容器内创建 jesse.java
    [root@iZbp1dd3rhnwjlzg9slrjjZ home]# docker ps
    CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES
    9b8d4a0c7748   centos    "/bin/bash"   20 minutes ago   Up 20 minutes             confident_cannon
    [root@iZbp1dd3rhnwjlzg9slrjjZ home]# docker exec -it 9b8d4a0c7748 /bin/bash
    [root@9b8d4a0c7748 /]# ls
    bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var
    dev  home  lib64  media       opt  root  sbin  sys  usr
    [root@9b8d4a0c7748 /]# cd /home
    [root@9b8d4a0c7748 home]# ls
    [root@9b8d4a0c7748 home]# touch jesse.java
    [root@9b8d4a0c7748 home]# ls
    jesse.java
    
    # 回到主机上 拷贝容器内部的 /home/jesse.java
    [root@iZbp1dd3rhnwjlzg9slrjjZ home]# ls
    [root@iZbp1dd3rhnwjlzg9slrjjZ home]# docker cp 9b8d4a0c7748:/home/jesse.java /home
    [root@iZbp1dd3rhnwjlzg9slrjjZ home]# ls
    jesse.java
    
    # 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现
    ~~~

#### 5.5 小结

* ~~~sh
  # docker其他命令
  attach    Attach to a running container                                  #当前shell下attach连接指定运行镜像
  build     Build an image from a Dockerfile                               #通过Dockerfile定制镜像
  commit    Create a new image from a containers changes                   #提交当前容器为新的镜像
  cp          Copy files/folders from a container to a HOSTDIR or to STDOUT  #从容器中拷贝指定文件或者目录到宿主机中
  create    Create a new container                                         #创建一个新的容器，同run 但不启动容器
  diff      Inspect changes on a containers filesystem                     #查看docker容器变化
  events    Get real time events from the server                           #从docker服务获取容器实时事件
  exec      Run a command in a running container                           #在已存在的容器上运行命令
  export    Export a containers filesystem as a tar archive                #导出容器的内容流作为一个tar归档文件(对应import)
  history   Show the history of an image                                   #展示一个镜像形成历史
  images    List images                                                    #列出系统当前镜像
  import    Import the contents from a tarball to create a filesystem image  #从tar包中的内容创建一个新的文件系统映像(对应export)
  info      Display system-wide information                                #显示系统相关信息
  inspect   Return low-level information on a container or image           #查看容器详细信息
  kill      Kill a running container                                       #kill指定docker容器
  load      Load an image from a tar archive or STDIN                      #从一个tar包中加载一个镜像(对应save)
  login     Register or log in to a Docker registry                        #注册或者登陆一个docker源服务器
  logout    Log out from a Docker registry                                 #从当前Docker registry退出
  logs      Fetch the logs of a container                                  #输出当前容器日志信息
  pause     Pause all processes within a container                         #暂停容器
  port      List port mappings or a specific mapping for the CONTAINER     #查看映射端口对应的容器内部源端口
  ps        List containers                                                #列出容器列表
  pull      Pull an image or a repository from a registry                  #从docker镜像源服务器拉取指定镜像或者库镜像
  push      Push an image or a repository to a registry                    #推送指定镜像或者库镜像至docker源服务器
  rename    Rename a container                                             #重命名容器
  restart   Restart a running container                                    #重启运行的容器
  rm        Remove one or more containers                                  #移除一个或者多个容器
  rmi       Remove one or more images                                      #移除一个或多个镜像(无容器使用该镜像才可以删除，否则需要删除相关容器才可以继续或者-f强制删除)
  run       Run a command in a new container                               #创建一个新的容器并运行一个命令
  save      Save an image(s) to a tar archive                              #保存一个镜像为一个tar包(对应load)
  search    Search the Docker Hub for images                               #在docker hub中搜索镜像
  start     Start one or more stopped containers                           #启动容器
  stats     Display a live stream of container(s) resource usage statistics  #统计容器使用资源
  stop      Stop a running container                                       #停止容器
  tag       Tag an image into a repository                                 #给源中镜像打标签
  top       Display the running processes of a container                   #查看容器中运行的进程信息
  unpause   Unpause all processes within a container                       #取消暂停容器
  version   Show the Docker version information                            #查看容器版本号
  wait      Block until a container stops, then print its exit code        #截取容器停止时的退出状态值
  ~~~

### 六.Docker配置Nginx

* ~~~shell
  # 搜索镜像
  [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker search nginx
  NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
  nginx                             Official build of Nginx.                        15719     [OK]       
  # 拉取镜像
  [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker pull nginx
  Using default tag: latest
  latest: Pulling from library/nginx
  b380bbd43752: Pull complete 
  fca7e12d1754: Pull complete 
  745ab57616cb: Pull complete 
  a4723e260b6f: Pull complete 
  1c84ebdff681: Pull complete 
  858292fd2e56: Pull complete 
  Digest: sha256:644a70516a26004c97d0d85c7fe1d0c3a67ea8ab7ddf4aff193d9f301670cf36
  Status: Downloaded newer image for nginx:latest
  docker.io/library/nginx:latest
  
  [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker images
  REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
  nginx        latest    87a94228f133   2 weeks ago   133MB
  centos       latest    5d0da3dc9764   6 weeks ago   231MB
  
  # 启动镜像
  # -d 后台运行 --name Nginx01 指定名字 1999对外暴露接口 80为nginx默认接口
  [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker run -d --name Nginx01 -p 1999:80 nginx
  fa46e2e8f1f54c3c637eacce04e29398348acf092abb8c4ac09ee484ce232114
  
  [root@iZbp1dd3rhnwjlzg9slrjjZ /]# docker ps
  CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                  NAMES
  fa46e2e8f1f5   nginx     "/docker-entrypoint.…"   8 seconds ago   Up 6 seconds   0.0.0.0:1999->80/tcp   Nginx01
  
  # 测试是否启动成功
  
  # 本机自测 成功
  [root@iZbp1dd3rhnwjlzg9slrjjZ home]# curl localhost:1999
  <!DOCTYPE html>
  <html>
  <head>
  <title>Welcome to nginx!</title>
  <style>
  html { color-scheme: light dark; }
  body { width: 35em; margin: 0 auto;
  font-family: Tahoma, Verdana, Arial, sans-serif; }
  </style>
  </head>
  <body>
  <h1>Welcome to nginx!</h1>
  <p>If you see this page, the nginx web server is successfully installed and
  working. Further configuration is required.</p>
  
  <p>For online documentation and support please refer to
  <a href="http://nginx.org/">nginx.org</a>.<br/>
  Commercial support is available at
  <a href="http://nginx.com/">nginx.com</a>.</p>
  
  <p><em>Thank you for using nginx.</em></p>
  </body>
  </html>
  
  # 外部测试
  【浏览器】访问： http://121.40.246.211:1999/ 出现 Welcome to Nginx 表示成功
  
  # 进入Nginx容器内部
  [root@iZbp1dd3rhnwjlzg9slrjjZ home]# docker exec -it Nginx01 /bin/bash
  root@fa46e2e8f1f5:/# whereis nginx
  nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx
  root@fa46e2e8f1f5:/# cd /etc/nginx
  root@fa46e2e8f1f5:/etc/nginx# ls
  conf.d	fastcgi_params	mime.types  modules  nginx.conf  scgi_params  uwsgi_params
  ~~~

* ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/Docker-%E7%AB%AF%E5%8F%A3%E6%9A%B4%E9%9C%B2%E7%A4%BA%E6%84%8F%E5%9B%BE.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/Docker-%E7%AB%AF%E5%8F%A3%E6%9A%B4%E9%9C%B2%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

* 思考问题：我们每次改动nginx配置文件，都需要进入容器内部？十分的麻烦，我要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改？ -v 数据卷！

### 七.Docker安装Tomcat

~~~shell
# 过程基本等于Nginx 这里只粘贴
[root@iZbp1dd3rhnwjlzg9slrjjZ home]# docker pull tomcat
Using default tag: latest
latest: Pulling from library/tomcat
bb7d5a84853b: Pull complete 
f02b617c6a8c: Pull complete 
d32e17419b7e: Pull complete 
c9d2d81226a4: Pull complete 
fab4960f9cd2: Pull complete 
da1c1e7baf6d: Pull complete 
1d2ade66c57e: Pull complete 
ea2ad3f7cb7c: Pull complete 
d75cb8d0a5ae: Pull complete 
76c37a4fffe6: Pull complete 
Digest: sha256:509cf786b26a8bd43e58a90beba60bdfd6927d2ce9c7902cfa675d3ea9f4c631
Status: Downloaded newer image for tomcat:latest
docker.io/library/tomcat:latest
[root@iZbp1dd3rhnwjlzg9slrjjZ home]# docker images
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
tomcat       latest    b0e0b0a92cf9   7 days ago    680MB
nginx        latest    87a94228f133   2 weeks ago   133MB
centos       latest    5d0da3dc9764   6 weeks ago   231MB
[root@iZbp1dd3rhnwjlzg9slrjjZ home]# docker run -d --name Tomcat04 -p 2000:8080 tomcat
de47ebeb32bb75d49ecb0f10dd480e7e47d468550ec7373c5157a86152d53f5c
[root@iZbp1dd3rhnwjlzg9slrjjZ home]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                    NAMES
de47ebeb32bb   tomcat    "catalina.sh run"        4 seconds ago   Up 3 seconds   0.0.0.0:2000->8080/tcp   Tomcat04
4e946e1a2e4a   nginx     "/docker-entrypoint.…"   3 minutes ago   Up 3 minutes   0.0.0.0:1999->80/tcp     Nginx02

# 测试访问没有问题
# 进入容器
[root@iZ8vbgc3u6dvwrjyp45lyrZ home]# docker exec -it tomcat01 /bin/bash
# 发现问题：1、linux命令少了，2、没有webapps，阿里云镜像的原因。默认是最小的镜像，所有不必要的都剔除掉了。
# 保证最小可运行的环境
~~~

### 八.Docker镜像

* 什么是镜像？

  镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。

  所有的应用，直接打包docker镜像，就可以直接跑起来！

  如何得到镜像：

  - 从远程仓库下载
  - 朋友拷贝给你
  - 自己制作一个镜像DockerFile

* **UnionFS(联合文件系统)**

  * 分层下载就是UnionFS的体现
  * Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。

  * 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把文件系统及叠加起来，这样最终的文件系统包含所有底层的文件和目录

* **Docker镜像加载原理**

  * docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。
    * bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们电箱的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。
    * rootfs（root file system），在bootfs之上。包含的就是典型Linux 系统中的 /dev，/proc，/bin，/etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。
    * ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/20210721144206155.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/20210721144206155.png)
    * e.g. docker上的Centos才200MB 很小 为什么？
      * 对于个精简的OS,rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， boots基本是一致的， rootfs会有差別，因此不同的发行版可以公用bootfs。

* **Docker分层**

* 所有的docker镜像都起始于一个基础镜像层，当进行修改或者增加新的内容时，就会在当前镜像层之上，创建新的镜像层。

  举一个简单的例子，加入基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上穿件第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。

  该镜像当前已经包含3个镜像层，如下图（这只是一个用于演示的很简单的例子）。

  * ​	![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/1.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/1.png)

  * 在添加额外的镜像层的同时，镜像始终是保持当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像层包含了来自两镜像层的6个文件。

    * ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/2.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/2.png)

  * 上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。

    下图总展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层的文件7是文件5的一个更新版本。

  * ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/3.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/3.png)

  * 这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。

  * Docker通过存储引擎（新版本采用快照机制)的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。

> **特点**
>
> Docker镜像都是只读的，当容器启东时，一个新的可写层被加载到镜像的顶部！
>
> 这一层就是我们通常说的容器层，容器之下的都叫镜像层。

* **提交镜像**

  * ~~~bash
    docker commit 提交容器成为一个新的副本
    # 命令和git原理类似
    docker commit -m="描述信息" -a="作者" 容器id 目标镜像名:[TAG]
    ~~~

  * ~~~shell
    # 1、启动一个默认的tomcatdocker run -d -p 8080:8080 tomcat
    # 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！docker exec -it 容器id# 
    # 3、拷贝文件进去# 
    # 4、将操作过的容器通过commit**为一个镜像！我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像。
    docker commit -m="描述信息" -a="作者" 容器id 目标镜像名:[TAG]
    
    docker commit -a="kuangshen" -m="add webapps app" 容器id tomcat02:1.0
    
    #测试
    [root@iZbp1dd3rhnwjlzg9slrjjZ home]# docker ps
    CONTAINER ID   IMAGE     COMMAND                  CREATED             STATUS             PORTS                    NAMES
    de47ebeb32bb   tomcat    "catalina.sh run"        58 minutes ago      Up 58 minutes      0.0.0.0:2000->8080/tcp   Tomcat04
    4e946e1a2e4a   nginx     "/docker-entrypoint.…"   About an hour ago   Up About an hour   0.0.0.0:1999->80/tcp     Nginx02
    [root@iZbp1dd3rhnwjlzg9slrjjZ home]# docker commit -a="mazhijian" -m="test create a new Tomcat image" de47ebeb32bb test_new_tomcat:1.0 
    sha256:4f8e818c55f89182017c9247ca97fd3f33469b338f812df5a762d9655f152cfa
    [root@iZbp1dd3rhnwjlzg9slrjjZ home]# docker images
    REPOSITORY        TAG       IMAGE ID       CREATED         SIZE
    test_new_tomcat   1.0       4f8e818c55f8   4 seconds ago   684MB
    tomcat            latest    b0e0b0a92cf9   7 days ago      680MB
    redis             latest    7faaec683238   2 weeks ago     113MB
    nginx             latest    87a94228f133   2 weeks ago     133MB
    centos            latest    5d0da3dc9764   6 weeks ago     231MB
    ~~~

  * 如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比我们我们使用虚拟机的快照。

### 九.容器数据卷

#### 9.1 容器卷概念

* 将应用和环境打包成一个镜像！连带着数据。但如果数据都在容器中，那么我们容器删除，数据就会丢失！
  * 需求：数据可以持久化
  * MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！
  * 容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地
  * 这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！
  * 总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！
  * ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/20210721201603322.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/20210721201603322.png)

#### 9.2 使用数据卷

~~~sh
# 方式一 ：直接使用命令挂载 -v
-v, --volume list Bind mount a volume
docker run -it -v 主机目录:容器内目录    
[root@iZbp1dd3rhnwjlzg9slrjjZ ~]# docker run -it -v /home/ceshi:/home centos /bin/bash
#通过 docker inspect 容器id 查看

"Mounts": [
{
"Type": "bind",
"Source": "/home/ceshi",
"Destination": "/home",
"Mode": "",
"RW": true,
"Propagation": "rprivate"
}
],
~~~

* **测试Docker文件的同步**
* ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/docker%E5%AE%B9%E5%99%A8%E5%8D%B7%E5%90%8C%E6%AD%A5%E5%AE%9E%E4%BE%8B.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/docker%E5%AE%B9%E5%99%A8%E5%8D%B7%E5%90%8C%E6%AD%A5%E5%AE%9E%E4%BE%8B.png)

#### 9.3 MySql同步数据

* ~~~shell
  # 拉取Mysql镜像
  [root@iZbp1dd3rhnwjlzg9slrjjZ ceshi]# docker pull mysql:5.7
  5.7: Pulling from library/mysql
  b380bbd43752: Already exists 
  f23cbf2ecc5d: Pull complete 
  30cfc6c29c0a: Pull complete 
  b38609286cbe: Pull complete 
  8211d9e66cd6: Pull complete 
  2313f9eeca4a: Pull complete 
  7eb487d00da0: Pull complete 
  a71aacf913e7: Pull complete 
  393153c555df: Pull complete 
  06628e2290d7: Pull complete 
  ff2ab8dac9ac: Pull complete 
  Digest: sha256:2db8bfd2656b51ded5d938abcded8d32ec6181a9eae8dfc7ddf87a656ef97e97
  Status: Downloaded newer image for mysql:5.7
  docker.io/library/mysql:5.7
  
  [root@iZbp1dd3rhnwjlzg9slrjjZ ceshi]# docker images
  REPOSITORY        TAG       IMAGE ID       CREATED       SIZE
  test_new_tomcat   1.0       4f8e818c55f8   2 hours ago   684MB
  tomcat            latest    b0e0b0a92cf9   7 days ago    680MB
  mysql             5.7       938b57d64674   10 days ago   448MB
  redis             latest    7faaec683238   2 weeks ago   113MB
  nginx             latest    87a94228f133   2 weeks ago   133MB
  centos            latest    5d0da3dc9764   6 weeks ago   231MB
  
  # docker run -d -p 2001:3306 -v /home/ceshi/mysql/conf:/etc/mysql/conf.d -v /home/ceshi/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7
  
  # 启动成功后 连接 121.40.246.211:2001即可
  ~~~
  

#### 9.4 具名挂载和匿名挂载

* ~~~bash
  # 匿名挂载
  -v 容器内路径！
  docker run -d -p --name nginx01 -v /etc/nginx nginx
  # 查看所有的volume的情况
  [root@iZ8vbgc3u6dvwrjyp45lyrZ lib]# docker volume ls
  DRIVER    VOLUME NAME
  local     3df3ebf883092323908b31e21c761b56c937ee04ed51d418eedcc10df8d5f20a
  # 这里发现，这种就是匿名挂载，我们在 -v 只写了容器内的路径，没有写容器外的路径！
  # 具名挂载
  # 具名挂载
  ➜ ~ docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx
  ➜ ~ docker volume ls
  DRIVER         VOLUME NAME
  local         juming-nginx
  # 通过 -v 卷名：容器内路径
  # 查看一下这个卷
  
  # 所有的docker容器内的卷，没有指定目录的情况下都是在 /var/lib/docker/volumes/xxx/_data
  
  # 我们通过具名挂载可以方便的找到我们的 一个卷，大多数情况使用的是 具名挂载
  
  # 通过 -v 容器内路径： ro rw 改变读写权限
  ro readonly  # 只读
  rw readwrite # 可读可写
  # 一旦设置了容器权限，容器对我们挂载出来的内容就有限定了！
  docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx
  docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx
  # ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！
  ~~~

### 十. DockerFile

#### 10.1 认识DockerFile

* Dockerfile 就是用来构建docker镜像的构建文件！

  * 通过这个脚本可以生成镜像，镜像是一层一层的，脚本就是一个一个的命令

* ~~~shell
  # 创建一个dockerfile文件，名字可以随机 建议 Dockerfile
  # 文件中的内容 指令（大写）参数
  FROM centos
  VOLUME ["/volume01", "/volume02"]
  CMD echo  "----end----------"
  CMD /bin/bash
  # 这里的每个命令，就是镜像的一层！
  
  # 测试
  [root@iZbp1dd3rhnwjlzg9slrjjZ docker-test-volume]# pwd
  /home/docker-test-volume
  [root@iZbp1dd3rhnwjlzg9slrjjZ docker-test-volume]# vim dockerfile1
  [root@iZbp1dd3rhnwjlzg9slrjjZ docker-test-volume]# ls
  dockerfile1
  [root@iZbp1dd3rhnwjlzg9slrjjZ docker-test-volume]# cat dockerfile1 
  FROM centos
  
  VOLUME ["volume01","volume02"]
  
  CMD echo "#####end#####"
  CMD /bin/bash
  [root@iZbp1dd3rhnwjlzg9slrjjZ docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t 
  jesse/centos .
  Sending build context to Docker daemon  2.048kB
  Step 1/4 : FROM centos
   ---> 5d0da3dc9764
  Step 2/4 : VOLUME ["volume01","volume02"]
   ---> Running in f33b6546b112
  Removing intermediate container f33b6546b112
   ---> a9d3fedc17c6
  Step 3/4 : CMD echo "#####end#####"
   ---> Running in 1b5adeda312e
  Removing intermediate container 1b5adeda312e
   ---> b20e6865f9b7
  Step 4/4 : CMD /bin/bash
   ---> Running in ad9a5cb49014
  Removing intermediate container ad9a5cb49014
   ---> 7f68b76c0489
  Successfully built 7f68b76c0489
  Successfully tagged jesse/centos:latest
  
  [root@iZbp1dd3rhnwjlzg9slrjjZ docker-test-volume]# docker run -it jesse/centos /bin/bash
  [root@8c50f10f938d /]# ls -l
  total 56
  lrwxrwxrwx   1 root root    7 Nov  3  2020 bin -> usr/bin
  drwxr-xr-x   5 root root  360 Nov  1 10:39 dev
  drwxr-xr-x   1 root root 4096 Nov  1 10:39 etc
  drwxr-xr-x   2 root root 4096 Nov  3  2020 home
  lrwxrwxrwx   1 root root    7 Nov  3  2020 lib -> usr/lib
  lrwxrwxrwx   1 root root    9 Nov  3  2020 lib64 -> usr/lib64
  drwx------   2 root root 4096 Sep 15 14:17 lost+found
  drwxr-xr-x   2 root root 4096 Nov  3  2020 media
  drwxr-xr-x   2 root root 4096 Nov  3  2020 mnt
  drwxr-xr-x   2 root root 4096 Nov  3  2020 opt
  dr-xr-xr-x 108 root root    0 Nov  1 10:39 proc
  dr-xr-x---   2 root root 4096 Sep 15 14:17 root
  drwxr-xr-x  11 root root 4096 Sep 15 14:17 run
  lrwxrwxrwx   1 root root    8 Nov  3  2020 sbin -> usr/sbin
  drwxr-xr-x   2 root root 4096 Nov  3  2020 srv
  dr-xr-xr-x  13 root root    0 Sep 14 09:25 sys
  drwxrwxrwt   7 root root 4096 Sep 15 14:17 tmp
  drwxr-xr-x  12 root root 4096 Sep 15 14:17 usr
  drwxr-xr-x  20 root root 4096 Sep 15 14:17 var
  drwxr-xr-x   2 root root 4096 Nov  1 10:39 volume01 # 这两个目录就是刚才挂载的目录
  drwxr-xr-x   2 root root 4096 Nov  1 10:39 volume02
  
  [root@iZbp1dd3rhnwjlzg9slrjjZ docker-test-volume]# docker inspect ae686b97995a
  
  "Mounts": [
      {
          "Type": "volume",
          "Name": "3f0fb5cdffa56a0ff28198b24eea3e418b532b6ced8f9a128b69a810e0cac72f",
          "Source": "/var/lib/docker/volumes/3f0fb5cdffa56a0ff28198b24eea3e418b532b6ced8f9a128b69a810e0cac72f/_data",
          "Destination": "volume01",
          "Driver": "local",
          "Mode": "",
          "RW": true,
          "Propagation": ""
      },
      {
          "Type": "volume",
          "Name": "a894b7791e2ba22a3a1fb228ca135889fd91aec6fb65dcacafb0983e4541ebb6",
          "Source": "/var/lib/docker/volumes/a894b7791e2ba22a3a1fb228ca135889fd91aec6fb65dcacafb0983e4541ebb6/_data",
          "Destination": "volume02",
          "Driver": "local",
          "Mode": "",
          "RW": true,
          "Propagation": ""
      }
  ],
  
  ~~~

  ![](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/dockerfile%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5.png)

* ~~~bash
  # 多个容器间的数据同步
  
  --volumes-from list                Mount volumes from the specified container(s)
  # 测试，
  
  # 测试，可以删除docker01，查看一下docker02 和 docker03 是否还可以访问这个文件
  # 测试依旧可以访问
  
  # 多个mysql数据共享
  ➜ ~ docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7
  ➜ ~ docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01 mysql:5.7
  # 这个时候，可以实现两个容器数据同步！
  ~~~

  ![https://xiaoma9969.oss-cn-beijing.aliyuncs.com/dockerfile%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%97%B4%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5.png](https://xiaoma9969.oss-cn-beijing.aliyuncs.com/dockerfile%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%97%B4%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5.png)

* > 结论：

  * 容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。
  * 但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！

#### 10.2 DockerFile概述

* dockerfile 是用来构建docker镜像的文件！命令参数脚本！

* 构建步骤：

  1、 编写一个dockerfile文件

  2、 docker build 构建称为一个镜像

  3、 docker run运行镜像

  4、 docker push发布镜像（DockerHub 、阿里云仓库)

* ~~~bash
  # 官方纯净版(dockerfile文件) 一般功能简陋 所以可以自己创建镜像
  
  FROM scratch
  ADD centos-8-x86_64.tar.xz /
  LABEL org.label-schema.schema-version="1.0"     org.label-schema.name="CentOS Base Image"     org.label-schema.vendor="CentOS"     org.label-schema.license="GPLv2"     org.label-schema.build-date="20210915"
  CMD ["/bin/bash"]
  
  # 
  ~~~

#### 10.3 DockerFile

> ### 知识：
>
>  	1.	每隔DockerFile关键字都需要是大写字母
>  	2.	执行DockerFile指令是从上到下的
>  	3.	'#'表示注释
>  	4.	每个指令都会创建提交一个新的镜像

~~~shell
FROM             # 基础镜像，一切从这里开始构建
MAINTAINER        # 镜像是谁写的， 姓名+邮箱
RUN             # 镜像构建的时候需要运行的命令
ADD             # 步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录
WORKDIR         # 镜像的工作目录
VOLUME             # 挂载的目录
EXPOSE             # 保留端口配置
CMD             # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。
ENTRYPOINT         # 指定这个容器启动的时候要运行的命令，可以追加命令
ONBUILD         # 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指令。
COPY             # 类似ADD，将我们文件拷贝到镜像中
ENV             # 构建的时候设置环境变量！
~~~

#### 10.4 构建自己的Centos

> #### Docker Hub中 99% 镜像都是从这个基础镜像过来的`FROM scratch` , 然后配置需要的软件和配置来进行的构建

~~~bash
# 编写配置文件

FROM centos
MAINTAINER JesseGunning<18626659853@163.com>

ENV MYPATH /user/local
WORKDIR $MYPATH

RUN yum -y install vim
RUN yum -y install net-tools

EXPOSE 80

CMD echo $MYPATH
CMD echo "-----create successful.-----"
CMD /bin/bash

# 通过文件构建镜像

# 2、通过这个文件构建镜像
# 命令 docker build -f 文件路径 -t 镜像名:[tag] .

[root@iZbp1dd3rhnwjlzg9slrjjZ dockerfile]# docker build -f mydockerfile-centos -t mycentos:1.0 .
Sending build context to Docker daemon  2.048kB
Step 1/10 : FROM centos
 ---> 5d0da3dc9764
Step 2/10 : MAINTAINER JesseGunning<18626659853@163.com>
 ---> Running in 87333fe6d371
Removing intermediate container 87333fe6d371
 ---> a47c62eb5581
Step 3/10 : ENV MYPATH /user/local
 ---> Running in 8be714dd18bf
Removing intermediate container 8be714dd18bf
 ---> 2605c4335592
Step 4/10 : WORKDIR $MYPATH
 ---> Running in 5bcb3a8e97a8
Removing intermediate container 5bcb3a8e97a8
 ---> ee0949c0526a
Step 5/10 : RUN yum -y install vim
 ---> Running in 0c8fc8333e25
CentOS Linux 8 - AppStream                      5.7 MB/s | 9.5 MB     00:01    
CentOS Linux 8 - BaseOS                         8.1 MB/s | 7.5 MB     00:00    
CentOS Linux 8 - Extras                          14 kB/s |  10 kB     00:00    
Dependencies resolved.
================================================================================
 Package             Arch        Version                   Repository      Size
================================================================================
Installing:
 vim-enhanced        x86_64      2:8.0.1763-15.el8         appstream      1.4 M
Installing dependencies:
 gpm-libs            x86_64      1.20.7-17.el8             appstream       39 k
 vim-common          x86_64      2:8.0.1763-15.el8         appstream      6.3 M
 vim-filesystem      noarch      2:8.0.1763-15.el8         appstream       48 k
 which               x86_64      2.21-12.el8               baseos          49 k

Transaction Summary
================================================================================
Install  5 Packages

Total download size: 7.8 M
Installed size: 30 M
Downloading Packages:
(1/5): gpm-libs-1.20.7-17.el8.x86_64.rpm        262 kB/s |  39 kB     00:00    
(2/5): vim-filesystem-8.0.1763-15.el8.noarch.rp 1.1 MB/s |  48 kB     00:00    
(3/5): which-2.21-12.el8.x86_64.rpm             661 kB/s |  49 kB     00:00    
(4/5): vim-enhanced-8.0.1763-15.el8.x86_64.rpm  3.8 MB/s | 1.4 MB     00:00    
(5/5): vim-common-8.0.1763-15.el8.x86_64.rpm     10 MB/s | 6.3 MB     00:00    
--------------------------------------------------------------------------------
Total                                           5.4 MB/s | 7.8 MB     00:01     
warning: /var/cache/dnf/appstream-02e86d1c976ab532/packages/gpm-libs-1.20.7-17.el8.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 8483c65d: NOKEY
CentOS Linux 8 - AppStream                      112 kB/s | 1.6 kB     00:00    
Importing GPG key 0x8483C65D:
 Userid     : "CentOS (CentOS Official Signing Key) <security@centos.org>"
 Fingerprint: 99DB 70FA E1D7 CE22 7FB6 4882 05B5 55B3 8483 C65D
 From       : /etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial
Key imported successfully
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                        1/1 
  Installing       : which-2.21-12.el8.x86_64                               1/5 
  Installing       : vim-filesystem-2:8.0.1763-15.el8.noarch                2/5 
  Installing       : vim-common-2:8.0.1763-15.el8.x86_64                    3/5 
  Installing       : gpm-libs-1.20.7-17.el8.x86_64                          4/5 
  Running scriptlet: gpm-libs-1.20.7-17.el8.x86_64                          4/5 
  Installing       : vim-enhanced-2:8.0.1763-15.el8.x86_64                  5/5 
  Running scriptlet: vim-enhanced-2:8.0.1763-15.el8.x86_64                  5/5 
  Running scriptlet: vim-common-2:8.0.1763-15.el8.x86_64                    5/5 
  Verifying        : gpm-libs-1.20.7-17.el8.x86_64                          1/5 
  Verifying        : vim-common-2:8.0.1763-15.el8.x86_64                    2/5 
  Verifying        : vim-enhanced-2:8.0.1763-15.el8.x86_64                  3/5 
  Verifying        : vim-filesystem-2:8.0.1763-15.el8.noarch                4/5 
  Verifying        : which-2.21-12.el8.x86_64                               5/5 

Installed:
  gpm-libs-1.20.7-17.el8.x86_64         vim-common-2:8.0.1763-15.el8.x86_64    
  vim-enhanced-2:8.0.1763-15.el8.x86_64 vim-filesystem-2:8.0.1763-15.el8.noarch
  which-2.21-12.el8.x86_64             

Complete!
Removing intermediate container 0c8fc8333e25
 ---> d1d9e5c20d23
Step 6/10 : RUN yum -y install net-tools
 ---> Running in 13bb5f4dbd89
Last metadata expiration check: 0:00:17 ago on Mon Nov  1 11:23:57 2021.
Dependencies resolved.
================================================================================
 Package         Architecture Version                        Repository    Size
================================================================================
Installing:
 net-tools       x86_64       2.0-0.52.20160912git.el8       baseos       322 k

Transaction Summary
================================================================================
Install  1 Package

Total download size: 322 k
Installed size: 942 k
Downloading Packages:
net-tools-2.0-0.52.20160912git.el8.x86_64.rpm   2.1 MB/s | 322 kB     00:00    
--------------------------------------------------------------------------------
Total                                           349 kB/s | 322 kB     00:00     
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Preparing        :                                                        1/1 
  Installing       : net-tools-2.0-0.52.20160912git.el8.x86_64              1/1 
  Running scriptlet: net-tools-2.0-0.52.20160912git.el8.x86_64              1/1 
  Verifying        : net-tools-2.0-0.52.20160912git.el8.x86_64              1/1 

Installed:
  net-tools-2.0-0.52.20160912git.el8.x86_64                                     

Complete!
Removing intermediate container 13bb5f4dbd89
 ---> cdacef40fd1a
Step 7/10 : EXPOSE 80
 ---> Running in 450aa865c348
Removing intermediate container 450aa865c348
 ---> af2dc8d28c60
Step 8/10 : CMD echo $MYPATH
 ---> Running in efac71a19d14
Removing intermediate container efac71a19d14
 ---> 483c2dff30e2
Step 9/10 : CMD echo "-----create successful.-----"
 ---> Running in d2f86342a58f
Removing intermediate container d2f86342a58f
 ---> 867c854c55c8
Step 10/10 : CMD /bin/bash
 ---> Running in b31898f648ff
Removing intermediate container b31898f648ff
 ---> 8af0222f8e4d
Successfully built 8af0222f8e4d
Successfully tagged mycentos:1.0

[root@iZbp1dd3rhnwjlzg9slrjjZ dockerfile]# docker images
REPOSITORY        TAG       IMAGE ID       CREATED              SIZE
mycentos          1.0       8af0222f8e4d   About a minute ago   337MB
jesse/centos      latest    7f68b76c0489   47 minutes ago       231MB
test_new_tomcat   1.0       4f8e818c55f8   3 days ago           684MB
tomcat            latest    b0e0b0a92cf9   10 days ago          680MB
mysql             5.7       938b57d64674   13 days ago          448MB
redis             latest    7faaec683238   2 weeks ago          113MB
nginx             latest    87a94228f133   2 weeks ago          133MB
centos            latest    5d0da3dc9764   6 weeks ago          231MB

# 进入新镜像测试 ifconfig或vim 命令即可
~~~

> ```
> docker run -i -t tomcat /bin/bash
> ```
>
> #### docker中的/bin/bash的作用是因为docker后台必须运行一个进程，否则容器就会退出，在这里表示启动容器后启动bash。

* cmd与entrypoint区别

  * ~~~bash
    CMD             # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。
    ENTRYPOINT         # 指定这个容器启动的时候要运行的命令，可以追加命令
    
    # CMD
    
    # 编写dockerfile文件
    $ vim dockerfile-test-cmd
    FROM centos
    CMD ["ls","-a"]
    # 构建镜像
    $ docker build -f dockerfile-test-cmd -t cmd-test:0.1 .
    # 运行镜像
    $ docker run cmd-test:0.1
    .
    ..
    .dockerenv
    bin
    dev
    # 想追加一个命令 -l 成为ls -al
    $ docker run cmd-test:0.1 -l
    docker: Error response from daemon: OCI runtime create failed:container_linux.go:349: starting container process caused "exec: \"-l\":executable file not found in $PATH": unknown.
    ERRO[0000] error waiting for container: context canceled
    # cmd的情况下 -l 替换了CMD["ls","-l"]。 -l 不是命令所有报错
    
    # ENTRYPOINT
    
    # 编写dockerfile文件
    $ vim dockerfile-test-entrypoint
    FROM centos
    ENTRYPOINT ["ls","-a"]
    $ docker run entrypoint-test:0.1
    .
    ..
    .dockerenv
    bin
    dev
    etc
    home
    lib
    lib64
    lost+found ...
    # 我们的命令，是直接拼接在我们得ENTRYPOINT命令后面的
    $ docker run entrypoint-test:0.1 -l
    total 56
    drwxr-xr-x 1 root root 4096 May 16 06:32 .
    drwxr-xr-x 1 root root 4096 May 16 06:32 ..
    -rwxr-xr-x 1 root root 0 May 16 06:32 .dockerenv
    lrwxrwxrwx 1 root root 7 May 11 2019 bin -> usr/bin
    drwxr-xr-x 5 root root 340 May 16 06:32 dev
    drwxr-xr-x 1 root root 4096 May 16 06:32 etc
    drwxr-xr-x 2 root root 4096 May 11 2019 home
    lrwxrwxrwx 1 root root 7 May 11 2019 lib -> usr/lib
    lrwxrwxrwx 1 root root 9 May 11 2019 lib64 -> usr/lib64 ....
    ~~~

#### 10.5 构建Tomcat镜像

1、准备镜像文件

准备tomcat 和 jdk到当前目录，编写好README 。

2、编写dokerfile 官方命名```Dockerfile```，名为这样的文件在```docker bulid```无需使用 -f 命令寻找
